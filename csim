#!/usr/bin/perl
#
# Simulator for Warren's crazy small CPU.
# (c) 2017 Warren Toomey, GPL3.
use strict;
use warnings;
use Data::Dumper;
use Time::HiRes qw( usleep);

use constant {
    DADD  => 0,		# A + B decimal
    DSUB  => 1,		# A - B decimal
    AND   => 2,		# A & B
    OR    => 3,		# A | B
    XOR   => 4,		# A ^ B
    INCA  => 5,		# A + 1
    BFLAGS => 6,	# 0, flags set to B's value
    ZERO  => 7,		# 0
    ADD   => 8,		# A + B binary
    SUB   => 9,		# A - B binary
    PASSA => 10,	# A
    PASSB => 11,	# B
    MULLO => 12,	# A * B binary, high nibble
    MULHI => 13,	# A * B binary, low nibble
    DIV   => 14,	# A / B binary
    MOD   => 15,	# A % B binary
};

my @ALUopname= ( 'DADD', 'DSUB', 'AND', 'OR',
		 'XOR', 'INCA', 'BFLAGS', 'ZERO',
		 'ADD', 'SUB', 'PASSA', 'PASSB',
		 'MULLO', 'MULHI', 'DIV', 'MOD' );

my @TopRom;
my @BotRom;
my @Ram = (0) x 256;
my $debug = 0;
my $udelay = 0;		# usleep delay

# Get any optional arguments
while ( defined( $ARGV[0] ) && ( $ARGV[0] =~ m{^-} ) ) {
    # -d: debug
    if ( $ARGV[0] eq "-d" ) {
        $debug = 1; shift(@ARGV); next;
    }
    # -c: clock rate
    if ( $ARGV[0] eq "-c" ) {
        shift(@ARGV);
	$udelay= int(1000000 / shift(@ARGV));
	$|++; next;
    }
}

# Load in the two ROMs
open( my $IN, "<", "toprom.rom" ) || die("Can't open toprom.rom: $!\n");
<$IN>;
while (<$IN>) {
    chomp; push( @TopRom, map( { hex($_) } split( /\s+/, $_ ) ) );
}
close($IN);
open( $IN, "<", "botrom.rom" ) || die("Can't open botrom.rom: $!\n");
<$IN>;
while (<$IN>) {
    chomp; push( @BotRom, map( { hex($_) } split( /\s+/, $_ ) ) );
}
close($IN);

my ( $PC, $NZVC, $A, $B ) = ( 0, 0, 0, 0 );
while (1) {
    my $romaddr  = ( $NZVC << 8 ) + $PC;
    my $address  = $BotRom[$romaddr];
    my $ALUop    = $TopRom[$romaddr] & 0x7;
    my $PCincr   = ( $TopRom[$romaddr] >> 3 ) & 0x1;
    my $Aload    = ( $TopRom[$romaddr] >> 4 ) & 0x1;
    my $Bload    = ( $TopRom[$romaddr] >> 5 ) & 0x1;
    my $Asel     = ( $TopRom[$romaddr] >> 6 ) & 0x1;
    my $RAMwrite = ( $TopRom[$romaddr] >> 7 ) & 0x1;

    # Include Asel as part of the ALUop
    $ALUop= $ALUop + ($Asel << 3);

    printf( "PC %x flags %x address %x cntrl %x ",
        $PC, $NZVC, $address, $TopRom[$romaddr] ) if ($debug);

    if ($PCincr) {
        $PC++;
    } else {
        exit(0) if ( $PC == $address );
        $PC = $address;
    }

    if ( ($Aload==0) && ($Bload==0) ) {
        print( chr( ( $A << 4 ) + $B ) );
        printf( "Printed %x ", ( $A << 4 ) + $B ) if ($debug);
    }

    # ALU instruction
    if ($RAMwrite==0) {		# Active low
        my $result;
	my $Cin= $NZVC & 1;
	printf("%s: A %x B %x Cin %d ", 
	  $ALUopname[$ALUop], $A, $B, $Cin) if ($debug);

        # BCD operations
        if ( ($ALUop eq DADD) || ($ALUop eq DSUB) ) {

            # Result is zero for any input > 9
            if ( ( $A > 9 ) || ( $B > 9 ) ) {
                $result = 0;
            } else {
                $result = ($ALUop eq DADD) ? $A + $B + $Cin : $A - $B - $Cin;
            }

            # Work out any carry and zero. Never negative or overflow
            my ( $n, $z, $v, $c ) = ( 0, 0, 0, 0 );
            if ( $result > 9 ) {
                $c      = 1;
                $result = $result - 10;    # Back to single digit
            }
            if ( $result < 0 ) {
                $c      = 1;
                $result = $result + 10;    # Back to single digit
            }
            $z = 1 if ( $result == 0 );
            $NZVC = ( $n << 3 ) + ( $z << 2 ) + ( $v << 1 ) + $c;
            $Ram[$address] = $result;
            printf( "RAM %x now %x, NZVC %x\n",
		$address, $result, $NZVC ) if ($debug);
        } else {

          $result = $A & $B 	 if ( $ALUop eq AND );
          $result = $A | $B 	 if ( $ALUop eq OR );
          $result = $A ^ $B 	 if ( $ALUop eq XOR );
          $result = $A      	 if ( $ALUop eq PASSA );
          $result = $B      	 if ( $ALUop eq PASSB );
          $result = $A + $B + $Cin if ( $ALUop eq ADD );
          $result = $A - $B - $Cin if ( $ALUop eq SUB );
          $result = $A + 1  	 if ( $ALUop eq INCA );
          $result = 0  	 	 if ( $ALUop eq ZERO );
          $result = 0  	 	 if ( $ALUop eq BFLAGS );
          $result = $A % $B  	 if ( $ALUop eq MOD );
          $result = int($A / $B) if ( $ALUop eq DIV );
          $result = ($A * $B) % 0xf if ( $ALUop eq MULLO );
          $result = ($A * $B) >>4 if ( $ALUop eq MULHI );

          my $bit5 = $result & 0x10;
          $result &= 0xf;

          my ( $n, $z, $v, $c ) = ( 0, 0, 0, 0 );
          $n = 1 if ( $result & 0x8 );
          $z = 1 if ( $result == 0 );
          $c = 1 if $bit5;

          # Get the sign bits for both inputs and the result
          my $asign = $A & 0x8;
          my $bsign = $B & 0x8;
          my $rsign = $result & 0x8;

          # Inputs have same sign, different from result sign
          $v = 1 if ( ( $asign == $bsign ) && ( $rsign != $asign ) );
          $NZVC = ( $n << 3 ) + ( $z << 2 ) + ( $v << 1 ) + $c;

	  # But override all of the above for BFLAGS
	  $NZVC= $B if ( $ALUop eq BFLAGS );

          $Ram[$address] = $result;
          printf( "RAM %x now %x, NZVC %x",
		$address, $result, $NZVC ) if ($debug);
        }
    }

    if ($Aload==0) {	# Active low
        if   ($Asel) { $A = $Ram[$address]; }
        else         { $A = $address & 0xf; }
        printf( "A now %x ", $A ) if ($debug);
    }

    if ($Bload==0) {	# Active low
        if   ($Asel) { $B = $Ram[$address]; }
        else         { $B = $address & 0xf; }
        printf( "B now %x ", $B ) if ($debug);
    }
    usleep($udelay) if ($udelay);

    print("\n") if ($debug);
}
