Wed 11 Oct 08:08:10 AEST 2017
-----------------------------
Chris Baird showed a way to do function calls, but to make it more efficient
I need a new ALU operation. So it's time to bite the bullet and upgrade to
16 ALU operations. I've cloned CSC version 1 to this version, version 2.
I've made the wiring change to the logisim version and csim, but I haven't
defined the new ALU operations yet. Time to scribble on paper.

We have to worry about the Asel line, so there are two banks of eight ALU
operations. Here are the ones we need to keep from CSCv1:

    Operation		Result
    --------------------------
    ALUinca		A + 1
    ALUpassb		B
    ALUpassa		A
    ALUxor		A ^ B
    ALUdadd		A + B decimal
    ALUor		A | B
    ALUand		A & B
    ALUsub		A - B binary
    ALUadd		A + B binary

I want to bring in at least:

    ALUdsub		A - B decimal
    ALUbflags		anything, but flags set to B

That leaves five more operations. I'd suggest at least these four:

    ALUmullo		A * B binary, low  4 bits
    ALUmulhi		A * B binary, high 4 bits
    ALUdiv		A / B
    ALUmod		A % B

Are there other operations that would be more useful?

Looking at the existing uses of the ALU, along with the Asel control line,
we have to at least these operations when Asel is on: ALUadd, ALUpassa
and ALUpassb. So let's try to partition up the possible operations:

  Asel off		Asel on
---------------------------------
  ALUdadd		ALUadd
  ALUdsub		ALUsub
  ALUand		ALUpassa
  ALUop			ALUpassb
  ALUxor		ALUmullo
  ALUinca		ALUmulhi
  ALUbflags		ALUdiv
  <unallocated>		ALUmod

For now, I might put in ALUzero (output is zero) as the final operation,
and temporarily implement this in cas and csim, and make sure the old
programs can be reassembled and still work. I still need to work out what
useful result we can have for ALUbflags. For now, zero.

Wed 11 Oct 10:35:49 AEST 2017
-----------------------------
Right, I've made the changes, and I've tested that fibminksy still runs
under the new system. That doesn't means it is perfect yet, but it's a
start. Now to start defining some new instructions. hexbench2 also still
runs, which is excellent.

Wed 11 Oct 11:14:59 AEST 2017
-----------------------------
I wrote a test function with four callers, and it actually worked first
time, that is so excellent! It's called firstfunction.s.

I've added some more CPU instructions that use the new ALU operations.
I've just added the extra wire from the top ROM Asel output to A12 of
the ALU ROM. This is the "bank select" control line for the two banks
of eight ALU operations.

Hmm, I noticed that fibminsky stopped working. It was my change to
the CLC control lines. I've reverted to the old set of control lines,
but I should work out why it isn't working with the new ones.

Found it. I had a typo on the definition of ZERO, so the new CLC
which uses ALUzero was not right. Fixed.

Wednesday 11 October  18:59:16 AEST 2017
----------------------------------------
I decided to write up some documentation on the instruction set and
how to write assembly code, in the form of Instructions.md. I'm
happy with it now. I've moved the programs into an Examples directory.

Thursday 12 October  19:58:51 AEST 2017
---------------------------------------
A good day today. I've worked out how to convert and print an 8-bit
unsigned number as three decimal digits. Using this, I've been able
to modify the Minsky code to draw a full circle using VT100 escape
sequences. Chris suggests using the tek4014 escape sequences to
draw real pixels, and has sent me a Mandelbrot program so I can see
the escape sequences. I've updated some of the documentation. I've
added a -c clockrate option to csim, so I can show it down and make
it more like the real hardware. So now I can see it draw the circle
just like the real circuit would.

Friday 13 October  08:49:51 AEST 2017
-------------------------------------
I wrote a small program to explore all the control line combinations
to see which ones might be useful. Removing the duplicate instructions
with the same effect leaves 48 instructions. This doesn't include the
conditional instructions.  Maybe we need to come up with a way to
consistently name them all :)

Some of them I can see would be useful: ZEROMAB to zero A and B at
the same time. No, not useful as that implies a DAB, and we can
already DAB 0 to load A&B with a zero. Removed.

Saturday 14 October  15:28:38 AEST 2017
---------------------------------------
I'm working on a program that enumerates all winning tic tac toe
boards where X moves first. Had some trouble squeezing it into
the 256 instruction limit. Getting close. I can now find this:
181
818
100

but the code progresses on to do this:

181
818
110

Not sure why yet. OK, fixed, and the number of winning boards is
exactly the same as my Perl version, so I'm really happy that the
program produces a correct result.

Sunday 15 October  16:59:22 AEST 2017
-------------------------------------
I tried to write a recursive towers of Hanoi program, but it hurt my
brain too much so I unrolled each level as a separate function. Chris
asked for \ to continue lines, which I have just done. I also fixed
the wrong line numbers report by cas on errors. Now I've edited the
example programs to use \.

Tue 17 Oct 07:40:26 AEST 2017
-----------------------------
Over the past few days I've written a program to print out a
couple of stanzas of "Mel the Programmer", and also a Bubblesort
program. Nothing much else.

Saturday 21 October  09:04:44 AEST 2017
---------------------------------------
I started learning Verilog yesterday and I now have CSCv2 implemented
but not working in Verilog. Current situation: the control ROMs are
decoding the instructions, the A/B/Flags registers seem to work, the ALU
seems to work. I store 1 into RAM location 4 but when I read it back it is
0. $display shows the store and incorrect read. $monitor seems to show
an extra write of 0 into RAM location 4.

Saturday 21 October  12:11:22 AEST 2017
---------------------------------------
Fixed. I had a data_out reg in ram.v which needed to be a wire. Now
I'm getting the lsb column of fibminsky.s working but no carry into
the next column.

That's now fixed too. I wired Cin up to the wrong Flags output bit.
I found that $write can output ASCII characters without a newline.
So now the Verilog version of the CPU can run fibminsky.s! I'm pretty
chuffed that I could get a Verilog version up and running. Oh, and I
can now see the digital lines in GTKwave :) I'll put it up in the
Github repository soon.

Sunday 22 October  08:50:09 AEST 2017
-------------------------------------
Yesterday I decided to make v2 the stable version. I've updated all
the docs on the minnie and Github sites, and pointed everything to
the CSCv2 Github site. This morning Chris suggested I try yosys to
visualise the Verilog synthesis. It all looks good, no glaring errors. 

Sunday 22 October  21:27:23 AEST 2017
-------------------------------------
Heh, got 8-bit multiplies to work. I fixed a MULLO bug in the process.
Chris says he has wired up the CPU, but needs to build a clock signal
and some output ability.
